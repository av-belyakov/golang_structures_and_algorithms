// Примеры работы со строками
package stringspackage

import "strings"

//Когда дело доходит до объединения строк, в Go есть два основных подхода, и
//один из них может быть действительно неэффективным в некоторых условиях.
//Во время каждой итерации оператор += объединяет s со строкой значений. На первый
//взгляд, эта функция не может выглядеть неправильной. Но при такой реализации мы забываем об одной
//из основных характеристик строки: ее НЕИЗМЕНЯЕМОСТИ. Следовательно, каждая итерация
//не обновляет s; она перераспределяет новую строку в памяти, что существенно влияет на
//производительность этой функции. Для решения этой проблеммы необходимо использовать
//структуру Builder{} из пакета strings.

// StringsConcatBuilder функция добавляет строки друг к другу через промежуточный буфер
func StringsConcatBuilder(values []string) string {
	sb := strings.Builder{}
	for _, value := range values {
		_, _ = sb.WriteString(value)
	}

	return sb.String()
}

//Сначала мы создали strings.Структуру Builder, используя ее нулевое значение. Во время каждой итерации
//мы создавали результирующую строку, вызывая метод WriteString, который добавляет
//содержимое value в свой внутренний буфер, тем самым сводя к минимуму копирование в память.
//Обратите внимание, что WriteString возвращает ошибку в качестве второго вывода, но мы намеренно
//игнорируем ее. Действительно, этот метод никогда не вернет ошибку, отличную от нуля. Итак, какова цель
//этого метода, возвращающего ошибку как часть своей сигнатуры? strings.Builder реализует ввод-
//вывод.Интерфейс StringWriter, который содержит единственный метод: Write-
//String(s string) (n int, err ошибка). Следовательно, для соответствия этому интерфейсу,
//WriteString должен возвращать ошибку.

//Используя strings.Builder, мы также можем добавить:
// - slice байта с помощью Write
// - Один байт с помощью writeByte
// - Одну rune с помощью WriteRune
//Внутри strings.Builder содержит slice байтов. Каждый вызов WriteString приводит к
//вызову append в slice. Есть два воздействия. Во-первых, эта структура не должна использоваться
//одновременно, так как вызовы append приведут к условиям гонки. Второе, если будущая
//длина фрагмента уже известна, мы должны предварительно выделить его. Для этой цели,
//strings.Builder предоставляет метод Grow(n into), чтобы гарантировать место для еще одного байта.
//Перед итерацией мы вычисляем общее количество байт, которое будет содержать конечная строка, и
//присваиваем результату значение total. Обратите внимание, что нас интересует не количество rune,
//а количество байт, поэтому мы используем функцию len. Затем мы вызываем Grow, чтобы гарантировать
//пространство для общего количества байт, прежде чем выполнять итерацию по строкам.

// StringsConcatBuilderGrow функция добавляет строки друг к другу через промежуточный буфер заданного размера
func StringsConcatBuilderGrow(values []string) string {
	total := 0
	for i := 0; i < len(values); i++ {
		total += len(values[i])
	}
	sb := strings.Builder{}

	//здесь вычислив количество байт создаем буфер заданого размера
	sb.Grow(total)
	for _, value := range values {
		_, _ = sb.WriteString(value)
	}

	return sb.String()
}
