# Скрипт 'migration'

Скрипт 'migration' выполняет подготовку и последующую миграцию в БД Postgres и Clickhouse. Для корректной работы скрипта необходим
файл _.env_ следующего формата:

```yml
# Параметр влияющий на выполнение миграции или 'откат' предидущих миграций
ACTION_MIGRATE=up

# Настройки подключения к СУБД PostgreSQL
POSTGRES_HOST=
POSTGRES_PORT=
POSTGRES_DB=
POSTGRES_USER=
POSTGRES_PASSWORD=

# Настройки подключения к СУБД ClickHouse
CLICKHOUSE_HOST=
CLICKHOUSE_PORT=
CLICKHOUSE_HTTP_PORT=
CLICKHOUSE_DB=
CLICKHOUSE_USER=
CLICKHOUSE_PASSWORD=
```

Параметр _ACTION_MIGRATE_ может быть только _up_ или _down_ или его может вообще не быть если не предпологается откатывать миграции.

## Миграция в БД Postgres, некоторые особенности требующие пояснения

Для БД Postgres, миграция выполняется на основе файлов миграции находящихся в директории _postgres/migrations_.
Все файлы для миграции в БД Postgres должны быть подготовлены заранее. Сначало с помощью пакета **golang-migrate** создаются
пустые файлы миграции формата _<порядковое*число>*<наименование_миграции>.up.sql_ и
_<порядковое*число>*<наименование_миграции>.down.sql_. Где файл _<порядковое*число>*<наименование_миграции>.up.sql_
отвечает за миграцию в БД, а файл _<порядковое*число>*<наименование_миграции>.down.sql_ за 'откат' миграции к предыдущему
состоянию. Эти файлы создаются пустыми с помощью команды:

```bash
docker run --rm -u $(id -u):$(id -g) -v $PWD/golang-migrate/postgres/migrations:/db/migrations:rw golang-migrate:latest create -ext sql -dir /db/migrations -ext sql -tz UTC -seq create_new_user_table
```

при этом следует обращать внимание на пути монтирования томов docker контейнера.
После создания пустых файлов _<порядковое*число>*<наименование_миграции>.up.sql_ и _<порядковое*число>*<наименование_миграции>.down.sql_
оператор заполняет их командами SQL предназначенными для миграции и её отмены, соответственно.

## Миграция в БД Clickhouse, некоторые особенности требующие пояснения

Для БД Clickhouse, миграция выполняется на основе файлов миграции находящихся по пути _clickhouse/migrations_. Все файлы для миграции в
БД Clickhouse также должны быть подготовлены заранее с помощью пакета **golang-migrate**. Процесс формирования файлов миграции с помощью
данного пакета описывался ранее. Однако в случае с Clickhouse есть некоторые нюансы.

1. Формирование и заполнение файлов _<порядковое*число>*<наименование_миграции>.up.sql_ и _<порядковое*число>*<наименование_миграции>.down.sql_  
   выполняется автоматически в результате запуска скрипта _migration.sh_. Который берет на себя создание файлов миграции для БД Clickhouse их наполнения
   SQL командами и запуск пакета **golang-migrate** для осуществлении миграции.

2. Наполнение файлов _<порядковое*число>*<наименование_миграции>.up.sql_ и _<порядковое*число>*<наименование_миграции>.down.sql_
   осуществляется на на основе файлов-шаблонов расположенных в директории _clickhouse/templates_.

### Некоторые особенности и правила работы с файлами-шаблонами и вспомогательным файлом _.template-storage_

Файл _.template-storage_ и файлы-шаблоны расположенны в директории _clickhouse/templates_.

#### Файл _.template-storage_, особенности

Файл _.template-storage_ нужен для учета уже обработанных файлов-шаблонов, как только файл-шаблон попадает в файл _.template-storage_
он уже **не будет обрабатыватся повторно** при следующем запуске. Соответственно при его удалении можно повтороно обработать файл-шаблон. Удаление
файла _.template-storage_ приведёт к обработке всех файлов-шаблонов при следующем запуске скрипта _migration.sh_. Если файла
_.template-storage_ нет, такое может быть при первом запуске скрипта _migration.sh_ то файл будет создан автоматически
в момент запуска скрипта _migration.sh_.

#### Файлы-шаблоны

Файлы-шаблоны создаются оператором и заполняются SQL командами, однако при создании этих файлов есть некоторые правила и особенности.

1. Имя файла-шаблона должно соответствовать шаблону **'[0-9]{4}\_\*.tmp.sql'** только такие файлы будут обрабатыватся скриптом. Это сделано для
   сохранения и отслеживания порядка обработки шаблонов, от этого напрямую зависит порядок выполнения миграции.

2. На основе одного файла-шаблона формируются два файла миграции _<порядковое*число>*<наименование_миграции>.up.sql_ и
   _<порядковое*число>*<наименование_миграции>.down.sql_. Для того чтобы в файле-шаблоне разделить SQL команды с помощью которых будет выполнятся
   миграция и SQL команды с помощью которых будет выполнен 'откат' миграции, если это будет необходимо, файл-шаблон _должен содержать строку-разделитель_
   подобную **-- Below are the rollback commands**. SQL команды до этой строки воспринимаются как команды миграции, всё что после - команды 'отката'.
   Строки разделителя в файле-шаблоне может и не быть, тогда файл миграции _<порядковое*число>*<наименование_миграции>.down.sql_ будет пуст.

## Пример команды для создания новых файлов миграции вручную

Команда выполняется из директории с файлом docker-compose.yml

```bash
docker run --rm -u $(id -u):$(id -g) -v $PWD/golang-migrate/postgres/migrations:/db/migrations:rw golang-migrate:latest create -ext sql -dir /db/migrations -ext sql -tz UTC -seq create_new_user_table
```

Обращать внимание на пути в пробросе томов для docker контейнера.

### Пример команды для смены версии миграции в БД вручную

```bash
docker run -v "$PWD/postgres/migrations/":/migrations --network host golang-migrate:latest -path=/migrations/ -database postgresql://soc:yTa89-nMsf-GAbs2@localhost:5432/socdb?sslmode=disable force <номер версии>
```
